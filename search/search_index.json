{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Strawberry Django Extras</p> <p>Adds extra functionality built on top of Strawberry Django</p>"},{"location":"#available-features","title":"Available Features:","text":"<ul> <li> JWT Authentication with build in mutations</li> <li> Validations on input instantiation  </li> <li> Permission checking on input instantiation</li> <li> Pre-save/Post-save mutation hooks</li> <li> Nested mutations support</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>  pip install strawberry-django-extras\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Dive right in to the Quickstart guide here</p> <p></p>"},{"location":"#a-note-on-relay","title":"A note on Relay","text":"<p>Relay is not currently supported by this package. Some features might work with relay and others might not. At the moment there are no plans to support Relay. If you are a relay user and do test this package, please do provide feedback on what works and what doesn't.</p>"},{"location":"breaking_changes/","title":"Breaking Changes","text":""},{"location":"breaking_changes/#removal-of-convenience-imports-v020","title":"Removal of Convenience Imports (v0.2.0)","text":""},{"location":"breaking_changes/#summary","title":"Summary","text":"<p>All convenience imports have been removed from the main package <code>__init__.py</code> to prevent eager loading and resolve async context detection issues. This is a breaking change that requires updating all import statements in your code.</p>"},{"location":"breaking_changes/#why-this-change-was-made","title":"Why This Change Was Made","text":"<p>Convenience imports in <code>__init__.py</code> caused modules to be eagerly loaded during Django startup, which led to: - Field extensions being built in sync context during import time - Schema evaluation happening too early (before async context was available) - Crashes when mixing sync/async execution chains during testing</p> <p>By removing these imports, modules are only loaded when explicitly imported, ensuring proper async context detection.</p>"},{"location":"breaking_changes/#what-you-need-to-do","title":"What You Need to Do","text":"<p>Update all imports to use direct module paths instead of importing from the main package.</p>"},{"location":"breaking_changes/#migration-examples","title":"Migration Examples","text":""},{"location":"breaking_changes/#field-extensions","title":"Field Extensions","text":"<pre><code># \u274c OLD (no longer works)\nfrom strawberry_django_extras import (\n    mutation_hooks,\n    with_validation,\n    with_permissions,\n    with_cud_relationships,\n    with_total_count\n)\n\n# \u2705 NEW (required)\nfrom strawberry_django_extras.field_extensions import (\n    mutation_hooks,\n    with_validation,\n    with_permissions, \n    with_cud_relationships,\n    with_total_count\n)\n</code></pre>"},{"location":"breaking_changes/#jwt-authentication","title":"JWT Authentication","text":"<pre><code># \u274c OLD (no longer works)\nfrom strawberry_django_extras import JWTMutations\n\n# \u2705 NEW (required)\nfrom strawberry_django_extras.jwt.mutations import JWTMutations\n</code></pre>"},{"location":"breaking_changes/#input-types","title":"Input Types","text":"<pre><code># \u274c OLD (no longer works)\nfrom strawberry_django_extras import (\n    CRUDInput,\n    CRUDOneToOneCreateInput,\n    CRUDManyToManyUpdateInput\n)\n\n# \u2705 NEW (required)\nfrom strawberry_django_extras.inputs import (\n    CRUDInput,\n    CRUDOneToOneCreateInput,\n    CRUDManyToManyUpdateInput\n)\n</code></pre>"},{"location":"breaking_changes/#decorators","title":"Decorators","text":"<pre><code># \u274c OLD (no longer works)\nfrom strawberry_django_extras import sync_or_async\n\n# \u2705 NEW (required)\nfrom strawberry_django_extras.decorators import sync_or_async\n</code></pre>"},{"location":"breaking_changes/#module-structure","title":"Module Structure","text":"<p>The new import structure follows this pattern:</p> <pre><code>strawberry_django_extras/\n\u251c\u2500\u2500 decorators.py          # sync_or_async\n\u251c\u2500\u2500 field_extensions.py    # All field extensions and factory functions\n\u251c\u2500\u2500 inputs.py             # CRUD input types\n\u251c\u2500\u2500 lazy.py               # Context-aware lazy view/consumer classes\n\u2514\u2500\u2500 jwt/\n    \u2514\u2500\u2500 mutations.py      # JWTMutations\n</code></pre>"},{"location":"breaking_changes/#need-help","title":"Need Help?","text":"<ul> <li>Check the documentation for detailed examples</li> <li>All existing functionality remains the same - only import paths have changed</li> </ul>"},{"location":"community-projects/","title":"Community Projects","text":"<p>Community projects providing django integration with strawberry.</p> Project Description  strawberry-graphql-django  Provides powerful tools to generate GraphQL types, queries, mutations and resolvers from Django models.  strawberry-django-auth  Authentication System for Django using Strawberry."},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install strawberry-django-extras\n</code></pre>"},{"location":"quickstart/#jwt-authentication","title":"JWT Authentication","text":"<p>The JWT part of this package is heavily based on the django-graphql-jwt package. Noting that, not all features supported by that package are supported here. For details on what is supported please refer to the the JWT part of these docs.</p> <p></p>"},{"location":"quickstart/#add-the-jwt-authentication-backend-to-your-settings","title":"Add the JWT Authentication Backend to your settings","text":"settings.py<pre><code>  AUTHENTICATION_BACKENDS = [\n    'strawberry_django_extras.jwt.backend.JWTBackend',\n    'django.contrib.auth.backends.ModelBackend',\n]\n</code></pre>"},{"location":"quickstart/#add-the-jwt-middleware-to-your-settings","title":"Add the JWT Middleware to your settings","text":"settings.py<pre><code>  MIDDLEWARE = [\n    ...\n    \"strawberry_django_extras.jwt.middleware.jwt_middleware\",\n]\n</code></pre> <p>Note</p> <p>This implementation of the middleware is different from other implementations in that it is designed to handle token based authentication for all request containing the <code>Authorization</code> header regardless of wether the request is to be consumed by your GraphQL view. This aims to provide a unified way of authenticating via JWT tokens issued by this package accross your entire application. </p> <p>If the request contains the <code>Authorization</code> header and the token is valid, the user will be authenticated and the <code>request.user</code> will be set to the user  associated with the token. If the token is expired a <code>401</code> response will be returned along with <code>Token Expired</code>. If an invalid token is provided a <code>401</code> response will be returned along with <code>Invalid Token</code>.</p> <p>If the user is already authenticated by some previous middleware in your middleware stack it will be respected and the token will not be checked at all. The order of the middleware in your middleware stack is important and you can set it depending on your needs. </p> <p></p>"},{"location":"quickstart/#expose-the-mutations-in-your-graphql-schema","title":"Expose the mutations in your GraphQL schema","text":"schema.py<pre><code>from strawberry_django_extras.jwt.mutations import JWTMutations\n\n@strawberry.type\nclass Mutation:\n    request_token = JWTMutations.issue\n    revoke_token = JWTMutations.revoke\n    verify_token = JWTMutations.verify\n</code></pre>"},{"location":"quickstart/#override-any-settings-you-might-need-in-your-project-settings","title":"Override any settings you might need in your project settings.","text":"settings.py<pre><code>GRAPHQL_JWT = {\n    'JWT_ALGORITHM': 'EdDSA',\n    'JWT_VERIFY_EXPIRATION': True,\n    'JWT_LONG_RUNNING_REFRESH_TOKEN': True,\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(minutes=5)\n    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),\n    'JWT_AUTHENTICATE_INTROSPECTION': True,\n    'JWT_REFRESH_TOKEN_N_BYTES': 64,\n    'JWT_PRIVATE_KEY': base64.b64decode('YOUR_PRIVATE_KEY'),\n    'JWT_PUBLIC_KEY': base64.b64decode('YOUR_PUBLIC_KEY')\n}\n</code></pre> <p>If you set <code>JWT_LONG_RUNNING_REFRESH_TOKEN</code> to <code>True</code> you will need to add the following to your settings file:</p> settings.py<pre><code>INSTALLED_APPS = [\n    ...\n    'strawberry_django_extras.jwt.refresh_token.apps.RefreshTokenConfig',\n]\n</code></pre> <p>and run <code>python manage.py migrate</code> to create the refresh token model.</p> <p>If you set <code>JWT_AUTHENTICATE_INTROSPECTION</code> to <code>True</code> you will need to add an extension to the root of your schema:</p> schema.py<pre><code>from strawberry_django_extras.jwt.extensions import DisableAnonymousIntrospection\n\nschema = strawberry.Schema(\n    query=Query,\n    mutation=Mutation,\n    subscription=Subscription,\n    extensions=[\n        DisableAnonymousIntrospection,\n        ...\n    ]\n)\n</code></pre> <p></p>"},{"location":"quickstart/#mutation-hooks","title":"Mutation Hooks","text":"<p>Mutation hooks are provided via a <code>field_extension</code> and can be applied to any strawberry mutation.</p> hooks.py<pre><code>def update_user_pre(info: Info, mutation_input: UserUpdateInput):\n    mutation_input.lastname = mutation_input.lastname.lower()\n\nasync def update_user_post(\n    info: Info, \n    mutation_input: UserUpdateInput,\n    result: Any\n):\n    await log(f'User {result.id} updated')\n</code></pre> <p>and then applied to your mutation:</p> schema.py<pre><code>from strawberry_django_extras.field_extensions import mutation_hooks\nfrom strawberry_django import mutations\nfrom .hooks import update_user_pre, update_user_post\n\n@strawberry.type\nclass Mutation:\n    update_user: UserType = mutations.update(\n        UserInputPartial,\n        extensions=[\n            mutation_hooks(\n                pre=update_user_pre,\n                post_async=update_user_post\n            )\n        ]\n    )\n</code></pre> <p>Note</p> <p>You might have noticed that we are passing both a sync and an async function at the same time. This is possible because if the context is async the sync function will be wrapped with sync_to_async and awaited. If the context is sync passing post_async and pre_async will be ignored. In either case the async functions are awaited.</p> <p></p>"},{"location":"quickstart/#input-validations","title":"Input Validations","text":"<p>Much inspired by the way graphene-django-cud handles validation, this package provides a similar way to validate your input when the respective input classes are instantiated.</p> inputs.py<pre><code>@strawberry_django.input(get_user_model())\nclass UserInput:\n    firstname: auto\n    lastname: auto\n\n    def validate(self, info):\n        if self.firstname == self.lastname:\n            raise ValidationError(\n                \"Firstname and lastname cannot be the same\"\n            )\n\n    # Or for individual fields    \n    def validate_lastname(self, info, value):\n        if value == self.firstname:\n            raise ValidationError(\n                \"Firstname and lastname cannot be the same\"\n            )\n</code></pre> <p>When updating an existing object the <code>pk</code> will be available through <code>self.id</code> so you can validate values in comparison to existing ones. Also info is provided in case validations need to be run against the user making the request.</p> <p>Finally add this to each mutation that needs to run validations:</p> schema.py<pre><code>from strawberry_django_extras.field_extensions import with_validation\nfrom strawberry_django import mutations\n\n@strawberry.type\nclass Mutation:\n    create_user: UserType = mutations.create(\n        UserInput,\n        extensions=[with_validation()]\n    )\n</code></pre> <p></p>"},{"location":"quickstart/#permissions","title":"Permissions","text":"<p>Similarly to validations, permission checking is run on input instantiation. Since strawberry does not currently provide a way to pass <code>permission_classes</code> to input fields this package allows you to write your permission checking functions as part of the input class.</p> inputs.py<pre><code>@strawberry_django.input(get_user_model())\nclass UserInput:\n    firstname: auto\n    lastname: auto\n\n    def check_permissions(self, info):\n        if not info.context.user.is_staff:\n            raise PermissionDenied(\n                \"You need to be staff to do this\"\n            )\n\n    # Or for individual fields    \n    def check_permissions_lastname(self, info, value):\n        if value == info.context.user.lastname:\n            raise PermissionDenied(\n                \"You cannot create a user with the same lastname as you\"\n            )\n</code></pre> schema.py<pre><code>from strawberry_django_extras.field_extensions import with_permissions\nfrom strawberry_django import mutations\n\n@strawberry.type\nclass Mutation:\n    create_user: UserType = mutations.create(\n        UserInput,\n        extensions=[with_permissions()]\n    )\n</code></pre> <p>Note</p> <p>As documented by Strawberry extension order does matter so make sure you are passing the <code>with_permissions()</code> and <code>with_validation()</code> extensions in an order that makes sense for your project.</p> <p></p>"},{"location":"quickstart/#nested-mutations","title":"Nested Mutations","text":"<p>This package provides support for deeply nested mutations through a field extension and some wrapper input classes.</p> <p>It makes sense for the inputs to be different when updating an object vs creating one. So we provide different input wrappers for each type of operation. It also makes sense that the api provided would be different depending on the type of relationship between the related models. Brief explanations of each input wrapper is provided below. For details refer to relevant guide on nested mutations.</p>"},{"location":"quickstart/#wrappers-for-nested-objects-for-create-mutations","title":"Wrappers for nested objects for create mutations","text":""},{"location":"quickstart/#one-to-one","title":"One to One","text":"<p><code>CRUDOneToOneCreateInput</code> can be used when you want to create or assign a related object, alongside the creation of your root object. The resulting schema will provide two actions for your mutation <code>create</code> and <code>assign</code> which are mutually exclusive. <code>create</code> is of type <code>UserCreateInput</code> which you will need to provide and <code>assign</code> is of type <code>ID</code>. A brief example follows.</p> models.py<pre><code>    class User(AbstractBaseUser, PermissionsMixin):\n        firstname = models.CharField(max_length=30, blank=True)\n        lastname = models.CharField(max_length=30, blank=True)\n        email = models.EmailField(max_length=254, unique=True)   \n        USERNAME_FIELD = 'email'\n        EMAIL_FIELD = 'email'\n\n    class Goat(models.Model):\n        name = models.CharField(max_length=255, default=None, null=True, blank=True)\n        user = models.OneToOneField(User, related_name=\"goat\", on_delete=models.CASCADE, null=True, default=None)\n</code></pre> inputs.py<pre><code>    from strawberry_django_extras.inputs import CRUDOneToOneCreateInput\n\n    @strawberry_django.input(get_user_model())\n    class UserInput:\n        firstname: auto\n        lastname: auto\n        email: auto\n        password: auto\n        goat: Optional[CRUDOneToOneCreateInput[GoatInput]] = UNSET\n\n    @strawberry_django.input(Goat)\n    class GoatInput:\n        name: auto\n        user: Optional[CRUDOneToOneCreateInput['UserInput']] = UNSET\n</code></pre> schema.py<pre><code>    from strawberry_django_extras.field_extensions import with_cud_relationships\n    from strawberry_django import mutations\n\n    @strawberry.type\n    class Mutation:\n        create_user: UserType = mutations.create(\n            UserInput,\n            extensions=[with_cud_relationships()]\n        )\n\n        create_goat: GoatType = mutations.create(\n            GoatInput,\n            extensions=[with_cud_relationships()]\n        )\n</code></pre> <p>Now we can create or assign nested objects on either side of the relationship.</p> <pre><code>mutation {\n    createGoat(data: {\n        name: \"Marina\"\n        user: {\n            create: {\n                firstname: \"Lakis\"\n                lastname: \"Lalakis\"\n                email: \"lalakis@domaim.tld\"\n                password: \"abc\"\n            }\n        }\n    }) {\n        id\n        name\n        user {\n            id\n            lastname\n            firstname\n            email\n        }\n    }\n}\n</code></pre>"},{"location":"quickstart/#one-to-many","title":"One to Many","text":"<p><code>CRUDOneToManyCreateInput</code>. Similarly to the one to one wrapper it provides two actions <code>create</code> and <code>assign</code> which are mutually exclusive. The only difference is that the relationship is through a <code>ForeignKey</code> meaning the other side of the relationship would be Many to One requiring a different wrapper.</p>"},{"location":"quickstart/#many-to-one","title":"Many to One","text":"<p><code>CRUDManyToOneCreateInput</code>. This wrapper is used when the relationship is Many to One. It provides two actions <code>create</code> and <code>assign</code> which are NOT mutually exclusive. The inputs are of course lists and of type <code>SomeModelInput</code> and <code>ID</code> respectively.</p>"},{"location":"quickstart/#many-to-many","title":"Many to Many","text":"<p><code>CRUDManyToManyCreateInput</code> is provided for Many-to-Many relationships. It provides two actions <code>create</code> and <code>assign</code> which are NOT mutually exclusive. The inputs are ofcourse lists again but there's one important difference. They are internally wrapped again to provide a mechanism for the user to provide <code>through_defaults</code> for the relationship either on assignment or creation. The type for through_defaults is JSON and the values should follow snake case.</p>"},{"location":"quickstart/#wrappers-for-nested-objects-for-update-mutations","title":"Wrappers for nested objects for update mutations","text":"<p>These wrappers expect two inputs to be provided instead of the one that was necessary for creation. The first is for creation of new related objects when updating the current object and the second is for updates to the data of already related objects.</p>"},{"location":"quickstart/#one-to-one_1","title":"One to One","text":"<p><code>CRUDOneToOneUpdateInput</code> can be used when alongside an update mutation you want to update related objects. The resulting schema will provide three possible actions for your mutation and a boolean flag.</p> <ul> <li><code>create</code> of type <code>UserInput</code> used to create a new related object.</li> <li><code>assign</code> of type <code>ID</code> used to assign an existing objects as related. <p>Note that you can use <code>null</code> to remove the relationship if the field is nullable.</p> </li> <li><code>update</code> of type <code>UserPartial</code> used to update the fields of an existing related object.</li> <li><code>delete</code> of type <code>bool</code> indicating whether the related object should be deleted. <p>Note that this flag can be used together with assign or create to delete the previously related object.</p> </li> </ul>"},{"location":"quickstart/#one-to-many_1","title":"One to Many","text":"<p><code>CRUDOneToManyUpdateInput</code> can be used when alongside an update mutation you want to update related objects. The resulting schema will provide three possible actions for your mutation and a boolean flag. These are the same as the ones provided by the One to One wrapper, and they function in exactly the same fashion.</p> <p>For a more detailed explanation with examples please refer to the relevant guide on nested mutations.</p>"},{"location":"quickstart/#many-to-one_1","title":"Many to One","text":"<p><code>CRUDManyToOneUpdateInput</code> can be used when alongside an update mutation you want to update related objects. The resulting schema will provide four possible actions for your mutation. These are as follows:</p> <ul> <li><code>create</code> of type <code>List[UserInput]</code> used to create new related objects.</li> <li><code>assign</code> of type <code>List[ID]</code> used to assign relations with existing objects.</li> <li><code>update</code> of type <code>List[UserPartial]</code> used to update the fields of existing related objects.</li> <li><code>remove</code> of type <code>List[CRUDRemoveInput]</code> which wraps an <code>ID</code> and a <code>bool</code> flag indicating whether the removed object   should be deleted.</li> </ul>"},{"location":"quickstart/#many-to-many_1","title":"Many to Many","text":"<p><code>CRUDManyToManyUpdateInput</code> can be used when alongside an update mutation you want to update related objects. The resulting schema will provide four possible actions for your mutation. These are as follows:</p> <ul> <li><code>create</code> of type <code>List[CRUDManyToManyItem]</code> which wraps two inputs.<ul> <li><code>objectData</code> of type <code>UserInput</code> used for the fields of the related object.</li> <li><code>throughDefaults</code> of type <code>JSON</code> used for any data stored in the <code>through</code> model if one exists.</li> </ul> </li> <li><code>assign</code> of type <code>List[CRUDManyToManyID]</code> which wraps two inputs.<ul> <li><code>id</code> of type <code>ID</code> used to assign relations with existing objects.</li> <li><code>throughDefaults</code> of type <code>JSON</code> used for any data stored in the <code>through</code> model if one exists.</li> </ul> </li> <li><code>update</code> of type <code>List[CRUDManyToManyItemUpdate]</code> which wraps two inputs.<ul> <li><code>objectData</code> of type <code>UserPartial</code> used to update the fields of the related object.</li> <li><code>throughDefaults</code> of type <code>JSON</code> used to update the fields of the <code>through</code> model if one exists.</li> </ul> </li> <li><code>remove</code> of type <code>List[CRUDRemoveInput]</code> which wraps an <code>ID</code> and a <code>bool</code> flag indicating whether the removed object   should be deleted.</li> </ul> <p>For a more detailed explanation with examples please refer to the relevant guide on nested mutations.</p>"},{"location":"guide/hooks/","title":"Mutation Hooks","text":"<p>Mutation  hooks are provided via a <code>field_extension</code> and can be applied to any strawberry mutation.  hooks.py<pre><code>def update_user_pre(info: Info, mutation_input: UserUpdateInput):\n    mutation_input.lastname = mutation_input.lastname.lower()\n\nasync def update_user_post(\n    info: Info, \n    mutation_input: UserUpdateInput,\n    result: Any\n):\n    await log(f'User {result.id} updated')\n</code></pre></p> <p>and then applied to your mutation: schema.py<pre><code>from strawberry_django_extras.field_extensions import mutation_hooks\nfrom strawberry_django import mutations\nfrom .hooks import update_user_pre, update_user_post\n\n@strawberry.type\nclass Mutation:\n    update_user: UserType = mutations.update(\n        UserInputPartial,\n        extensions=[\n            mutation_hooks(\n                pre=update_user_pre,\n                post_async=update_user_post\n            )\n        ]\n    )\n</code></pre></p> <p>Note</p> <p>You might have noticed that we are passing both a sync and an async function at the same time. This is possible because if the context is async the sync function will be wrapped with sync_to_async and awaited. If the context is sync passing post_async and pre_async will be ignored. In either case the async functions are awaited.  </p> <p></p>"},{"location":"guide/jwt/","title":"JWT Authentication","text":"<p>For installation and basic configuration instructions please refer to the quick start guide.</p>"},{"location":"guide/jwt/#settings","title":"Settings","text":"<p>Settings can be configured by defining the <code>GRAPHQL_JWT</code> dictionary in your Django settings.</p> <p><pre><code>GRAPHQL_JWT = {\n    'JWT_ALGORITHM': 'EdDSA',\n    'JWT_VERIFY_EXPIRATION': True,\n    'JWT_LONG_RUNNING_REFRESH_TOKEN': True,\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(minutes=5),\n    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),\n    'JWT_AUTHENTICATE_INTROSPECTION': True,\n    'JWT_REFRESH_TOKEN_N_BYTES': 64,\n    'JWT_PRIVATE_KEY': base64.b64decode('YOUR_PRIVATE_KEY'),\n    'JWT_PUBLIC_KEY': base64.b64decode('YOUR_PUBLIC_KEY')\n}\n</code></pre> </p> <p>The following settings are available for this module:</p>"},{"location":"guide/jwt/#jwt_algorithm","title":"JWT_ALGORITHM","text":"<p>Algorithm used to sign the JWT. Defaults to <code>HS256</code>.</p>"},{"location":"guide/jwt/#jwt_audience","title":"JWT_AUDIENCE\u00b6","text":"<p>Audience claim (aud) to be included in the JWT. Defaults to <code>None</code>.</p>"},{"location":"guide/jwt/#jwt_issuer","title":"JWT_ISSUER","text":"<p>Issuer claim (iss) to be included in the JWT. Defaults to <code>None</code>.</p>"},{"location":"guide/jwt/#jwt_leeway","title":"JWT_LEEWAY","text":"<p>Leeway time for JWT expiration verification. Defaults to <code>0</code>.</p>"},{"location":"guide/jwt/#jwt_secret_key","title":"JWT_SECRET_KEY","text":"<p>Secret key used to sign the JWT. Defaults to <code>settings.SECRET_KEY</code>.</p>"},{"location":"guide/jwt/#jwt_public_key","title":"JWT_PUBLIC_KEY","text":"<p>Public key used to verify the JWT. Defaults to <code>None</code>.</p> <p>This assumes you are using asymmetric cryptography so <code>JWT_SECRET_KEY</code> is not used and <code>JWT_ALGORITH</code> must be set accordingly.</p>"},{"location":"guide/jwt/#jwt_private_key","title":"JWT_PRIVATE_KEY","text":"<p>Private key used to verify the JWT. Defaults to <code>None</code>.</p> <p>This assumes you are using asymmetric cryptography so <code>JWT_SECRET_KEY</code> is not used and <code>JWT_ALGORITH</code> must be set accordingly.</p>"},{"location":"guide/jwt/#jwt_verify","title":"JWT_VERIFY","text":"<p>Secret key verification. Defaults to <code>True</code>.</p>"},{"location":"guide/jwt/#jwt_encode_handler","title":"JWT_ENCODE_HANDLER","text":"<p>Function used to encode the JWT.</p>"},{"location":"guide/jwt/#jwt_decode_handler","title":"JWT_DECODE_HANDLER","text":"<p>Function used to decode the JWT.</p>"},{"location":"guide/jwt/#jwt_payload_handler","title":"JWT_PAYLOAD_HANDLER","text":"<p>Function used to generate the JWT payload.</p>"},{"location":"guide/jwt/#jwt_payload_get_username_handler","title":"JWT_PAYLOAD_GET_USERNAME_HANDLER","text":"<p>Function used to get the username from the user model.  <pre><code>lambda payload: payload.get(get_user_model().USERNAME_FIELD)\n</code></pre></p>"},{"location":"guide/jwt/#jwt_get_user_by_natural_key_handler","title":"JWT_GET_USER_BY_NATURAL_KEY_HANDLER","text":"<p>Function used to get the user by its natural key.  <pre><code>get_user_by_natural_key(username)\n</code></pre></p>"},{"location":"guide/jwt/#jwt_verify_expiration","title":"JWT_VERIFY_EXPIRATION","text":"<p>Expiration time verification. Defaults to <code>False</code>.</p>"},{"location":"guide/jwt/#jwt_expiration_delta","title":"JWT_EXPIRATION_DELTA","text":"<p>Expiration delta added to <code>utcnow()</code> to determine token expiration. Defaults to <code>datetime.timedelta(seconds=300)</code>.</p>"},{"location":"guide/jwt/#jwt_allow_refresh","title":"JWT_ALLOW_REFRESH","text":"<p>Enables token refresh. Defaults to <code>True</code>.</p> <p>If used together with <code>JWT_LONG_RUNNING_REFRESH_TOKEN</code> this will allow the user to refresh the token using the refresh token. Otherwise, the user will have to use his JWT token prior to expiration to get a new one.</p>"},{"location":"guide/jwt/#jwt_refresh_expiration_delta","title":"JWT_REFRESH_EXPIRATION_DELTA","text":"<p>Timedelta used for refresh token expiration. Defaults to <code>datetime.timedelta(days=7)</code>.</p>"},{"location":"guide/jwt/#jwt_long_running_refresh_token","title":"JWT_LONG_RUNNING_REFRESH_TOKEN","text":"<p>Enables long-running refresh tokens. Defaults to <code>False</code>.</p>"},{"location":"guide/jwt/#jwt_refresh_token_model","title":"JWT_REFRESH_TOKEN_MODEL","text":"<p>Model used for refresh tokens.</p>"},{"location":"guide/jwt/#jwt_refresh_token_n_bytes","title":"JWT_REFRESH_TOKEN_N_BYTES","text":"<p>Long-running refresh token number of bytes. Defaults to <code>20</code>.</p>"},{"location":"guide/jwt/#jwt_reuse_refresh_tokens","title":"JWT_REUSE_REFRESH_TOKENS","text":"<p>A new long-running refresh token is being generated but replaces the existing database record and thus invalidates the previous long running refresh token. Defaults to <code>False</code>.</p>"},{"location":"guide/jwt/#jwt_refresh_expired_handler","title":"JWT_REFRESH_EXPIRED_HANDLER","text":"<p>Function used to handle expired refresh tokens.</p>"},{"location":"guide/jwt/#jwt_get_refresh_token_handler","title":"JWT_GET_REFRESH_TOKEN_HANDLER","text":"<p>A custom function to retrieve a long time refresh token instance.</p>"},{"location":"guide/jwt/#jwt_auth_header_name","title":"JWT_AUTH_HEADER_NAME","text":"<p>Name of the HTTP header used for authentication. Defaults to <code>HTTP_AUTHORIZATION</code>.</p>"},{"location":"guide/jwt/#jwt_auth_header_prefix","title":"JWT_AUTH_HEADER_PREFIX","text":"<p>Prefix for the HTTP header used for authentication. Defaults to <code>JWT</code>.</p>"},{"location":"guide/jwt/#jwt_authenticate_introspection","title":"JWT_AUTHENTICATE_INTROSPECTION","text":"<p>Limits introspection to authenticated users. Defaults to <code>False</code>.</p>"},{"location":"guide/lazy_loading/","title":"Lazy Loading","text":"<p>This package provides context-aware lazy loading classes that solve async context detection problems by deferring schema building until the first request or WebSocket connection. This ensures that schema evaluation happens in the correct execution context.</p>"},{"location":"guide/lazy_loading/#available-exports","title":"Available Exports","text":"<p>The <code>lazy</code> module provides two main classes:</p> <ul> <li><code>ContextAwareLazyView</code> - For HTTP GraphQL endpoints</li> <li><code>ContextAwareLazyConsumer</code> - For WebSocket GraphQL endpoints</li> </ul> <p>Both classes defer parent class initialization until the first interaction, ensuring schema building happens when async context is guaranteed to be available.</p>"},{"location":"guide/lazy_loading/#critical-requirements","title":"Critical Requirements","text":"<p>Schema Must Be Passed as String</p> <p>Both lazy classes MUST receive the schema as a string module path (e.g., <code>\"app.schema\"</code>), NOT as a direct schema object. This is critical for preventing early schema evaluation.</p> <pre><code>ContextAwareLazyView.as_view(schema=\"app.schema\")\n</code></pre> <p>Schema Import Isolation</p> <p>For lazy loading to work properly, your schema should NOT be imported anywhere else in your codebase during Django startup. Strawberry evaluates schemas at import time, so any import will trigger early schema building and defeat the lazy loading mechanism.</p>"},{"location":"guide/lazy_loading/#performance-considerations","title":"Performance Considerations","text":"<p>First Request Latency</p> <p>Since schema building is deferred until the first request/connection, expect some additional latency on the initial interaction. Subsequent requests will use the cached schema and perform normally.</p>"},{"location":"guide/lazy_loading/#http-graphql-endpoints","title":"HTTP GraphQL Endpoints","text":"<p>Use <code>ContextAwareLazyView</code> for standard HTTP GraphQL endpoints:</p> urls.py<pre><code>from django.urls import path\nfrom strawberry_django_extras.lazy import ContextAwareLazyView\n\nurlpatterns = [\n    path(\"graphql/\", ContextAwareLazyView.as_view(schema=\"app.schema\")),\n]\n</code></pre> app/schema.py<pre><code>import strawberry\nfrom strawberry_django_extras.field_extensions import with_total_count\n\n@strawberry.type\nclass Query:\n    users: list[UserType] = strawberry_django.field(\n        extensions=[with_total_count()]\n    )\n\n@strawberry.type \nclass Mutation:\n    # Your mutations here\n    pass\n\nschema = strawberry.Schema(query=Query, mutation=Mutation)\n</code></pre>"},{"location":"guide/lazy_loading/#websocket-graphql-endpoints","title":"WebSocket GraphQL Endpoints","text":"<p>Use <code>ContextAwareLazyConsumer</code> for GraphQL subscriptions over WebSocket:</p> asgi.py<pre><code>import os\n\nfrom channels.routing import ProtocolTypeRouter, URLRouter\nfrom django.core.asgi import get_asgi_application\nfrom django.urls import re_path\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"app.settings\")\ndjango_asgi_app = get_asgi_application()\n\nfrom strawberry_django_extras.lazy import ContextAwareLazyConsumer  # noqa: E402\n\ngql_ws_consumer = ContextAwareLazyConsumer.as_asgi(schema=\"app.schema\")\n\napplication = ProtocolTypeRouter({\n    \"http\": URLRouter(\n        [\n            re_path(\"^\", django_asgi_app),\n        ],\n    ),\n    \"websocket\": URLRouter([\n        re_path(r\"graphql\", gql_ws_consumer),\n    ]),\n})\n</code></pre> app/schema.py<pre><code>import strawberry\nfrom strawberry_django_extras.field_extensions import mutation_hooks\n\n@strawberry.type\nclass Query:\n    # Your queries here\n    pass\n\n@strawberry.type\nclass Mutation:\n    # Your mutations here  \n    pass\n\n@strawberry.type\nclass Subscription:\n    # Your subscriptions here\n    pass\n\nschema = strawberry.Schema(\n    query=Query, \n    mutation=Mutation, \n    subscription=Subscription\n)\n</code></pre>"},{"location":"guide/lazy_loading/#when-to-use-lazy-loading","title":"When to Use Lazy Loading","text":"<p>Lazy loading is particularly beneficial when:</p> <ul> <li>Running Django tests with async GraphQL operations</li> <li>Experiencing async context detection issues</li> <li>Using field extensions that need to detect execution context</li> <li>Working in hybrid sync/async environments</li> </ul> <p>Django Testing</p> <p>Lazy loading is especially useful for Django testing scenarios where schemas are imported during URL resolution (sync context) but executed in async context via <code>async_to_sync()</code>.</p>"},{"location":"guide/mutations/","title":"Nested Mutations","text":"<p>This package provides support for deeply nested mutations through a field extension and some wrapper input classes. </p> <p>It makes sense for the inputs to be different when updating an object vs creating one. So we provide different input wrappers for each type of operation.  It also makes sense that the api provided would be different depending on the type of relationship between the related models. </p>"},{"location":"guide/mutations/#wrappers-for-nested-objects-for-create-mutations","title":"Wrappers for nested objects for create mutations","text":""},{"location":"guide/mutations/#one-to-one","title":"One to One","text":"<p><code>CRUDOneToOneCreateInput</code> can be used when you want to create or assign a related object, alongside the creation of your root object. The resulting schema will provide two actions for your mutation <code>create</code> and <code>assign</code> which are mutually exclusive. <code>create</code> is of type <code>UserCreateInput</code> which you will need to provide and <code>assign</code> is of type <code>ID</code>. A brief example follows. models.py<pre><code>    class User(AbstractBaseUser, PermissionsMixin):\n        firstname = models.CharField(max_length=30, blank=True)\n        lastname = models.CharField(max_length=30, blank=True)\n        email = models.EmailField(max_length=254, unique=True)   \n        USERNAME_FIELD = 'email'\n        EMAIL_FIELD = 'email'\n\n    class Goat(models.Model):\n        name = models.CharField(max_length=255, default=None, null=True, blank=True)\n        user = models.OneToOneField(User, related_name=\"goat\", on_delete=models.CASCADE, null=True, default=None)\n</code></pre> inputs.py<pre><code>    from strawberry_django_extras.inputs import CRUDOneToOneCreateInput\n\n    @strawberry_django.input(get_user_model())\n    class UserInput:\n        firstname: auto\n        lastname: auto\n        email: auto\n        password: auto\n        goat: Optional[CRUDOneToOneCreateInput[GoatInput]] = UNSET\n\n    @strawberry_django.input(Goat)\n    class GoatInput:\n        name: auto\n        user: Optional[CRUDOneToOneCreateInput['UserInput']] = UNSET\n</code></pre> schema.py<pre><code>    from strawberry_django_extras.field_extensions import with_cud_relationships\n    from strawberry_django import mutations\n\n    @strawberry.type\n    class Mutation:\n        create_user: UserType = mutations.create(\n            UserInput,\n            extensions=[with_cud_relationships()]\n        )\n\n        create_goat: GoatType = mutations.create(\n            GoatInput,\n            extensions=[with_cud_relationships()]\n        )\n</code></pre></p> <p>Now we can create or assign nested objects on either side of the relationship. <pre><code>mutation {\n  createGoat(data: {\n    name: \"Marina\"\n    user: {\n      create: {\n        firstname: \"Lakis\"\n        lastname: \"Lalakis\"\n        email: \"lalakis@domaim.tld\"\n        password: \"abc\"\n      }\n    }\n  }) {\n    id\n    name\n    user {\n      id\n      lastname\n      firstname\n      email\n    }\n  }\n}\n</code></pre></p> <p>Or we could create the goat through the creation of the user. <pre><code>mutation {\n  createUser(data: { \n    firstname: \"Costas\"\n    lastname: \"Papadopoulos\"\n    email: \"papado@domain.tld\", \n    password: \"abc\"\n    goat: {\n      create: {\n        name: \"Mpempeka\"\n      }\n    }\n  }) {\n    id\n    lastname\n    firstname\n    email\n    goat {\n      id\n      name\n    }\n  }\n}\n</code></pre></p> <p>We could ofcourse use the <code>assign</code> action to assign an existing goat to a user or vice versa by providing the ID.</p> <p>Note</p> <p>There is no limit to how deeply nested the mutations can be. If the goat had a second relationship to another model say <code>Collar</code> and <code>Collar</code> had a relationship  back to the <code>User</code> model through a <code>designer</code> field we could create or assign the nested objects in one go.</p>"},{"location":"guide/mutations/#one-to-many","title":"One to Many","text":"<p><code>CRUDOneToManyCreateInput</code>. Similarly to the one to one wrapper it provides two actions <code>create</code> and <code>assign</code> which are mutually exclusive. The only difference is  that the relationship is through a <code>ForeignKey</code> meaning the other side of the relationship would be Many to One requiring a different wrapper. Here's a brief example:</p> <p><pre><code>mutation {\n  createGoat(data: {\n    name: \"Marina\"\n    child: {\n      create: {\n        name: \"Mpempeka\"\n        child: {\n          create: {\n            name: \"Mpempis\"\n            child: {\n              assign: \"72\"                \n            }\n          }\n        }\n      }\n    }\n  }) {\n    id\n    name\n    child {\n      ...\n    }\n  }\n}\n</code></pre> In the above example we can populate the entire genealogy of the goat with <code>pk</code> <code>72</code> in one go.</p>"},{"location":"guide/mutations/#many-to-one","title":"Many to One","text":"<p><code>CRUDManyToOneCreateInput</code>. This wrapper is used when the relationship is Many to One. It provides two actions <code>create</code> and <code>assign</code> which are NOT mutually exclusive. The inputs are of course lists and of type <code>SomeModelInput</code> and <code>ID</code> respectively. Here's a brief example:</p> <pre><code>mutation {\n  createUser(data: { \n    firstname: \"Costas\"\n    lastname: \"Papadopoulos\"\n    email: \"papado@domain.tld\", \n    password: \"abc\"\n    goats: {\n      create: [\n        {name: \"Myrto\"},\n        {name: \"Aliki\"}\n      ]\n      assign: [\n        \"29\",\n        \"30\"\n      ]\n    }\n  }\n  ) {\n    id\n    lastname\n    firstname\n    email\n    goats {\n      id\n      name\n    }\n  }\n}\n</code></pre>"},{"location":"guide/mutations/#many-to-many","title":"Many to Many","text":"<p><code>CRUDManyToManyCreateInput</code> is provided for Many-to-Many relationships. It provides two actions <code>create</code> and <code>assign</code> which are NOT mutually exclusive. The inputs are ofcourse lists again but there's one important difference. They are internally wrapped again to provide a mechanism for the user to provide <code>through_defaults</code> for the relationship either on assignment or creation. The type for through_defaults is JSON and the values should follow snake case.  </p> <p>Note</p> <p>Please note that the inputs for the nested objects need not be the same as the inputs for the creation of the objects. In fact you have the flexibility to define different inputs for the nested objects limiting which fields are exposed through each nested mutation. </p>"},{"location":"guide/mutations/#wrappers-for-nested-objects-for-update-mutations","title":"Wrappers for nested objects for update mutations","text":"<p>These wrappers expect two inputs to be provided instead of the one that was necessary for creation. The first is for creation of new related objects when updating the current  object and the second is for updates to the data of already related objects.</p>"},{"location":"guide/mutations/#one-to-one_1","title":"One to One","text":"<p><code>CRUDOneToOneUpdateInput</code> can be used when alongside an update mutation you want to update related objects. The resulting schema will provide three possible actions for your  mutation and a boolean flag. </p> <ul> <li><code>create</code> of type <code>UserInput</code> used to create a new related object.</li> <li><code>assign</code> of type <code>ID</code> used to assign an existing objects as related. <p>Note that you can use <code>null</code> to remove the relationship if the field is nullable.</p> </li> <li><code>update</code> of type <code>UserPartial</code> used to update the fields of an existing related object.</li> <li><code>delete</code> of type <code>bool</code> indicating whether the related object should be deleted. <p>Note that this flag can be used together with assign or create to delete the previously related object.</p> </li> </ul> <p>The respective update input of the example used for the One to One creation mutation above would read: <pre><code>@strawberry_django.partial(Goat)\nclass GoatPartial:\n    id: ID\n    name: auto\n    user: Optional[CRUDOneToOneUpdateInput['UserInput','UserPartial']] = UNSET\n\n@strawberry_django.partial(get_user_model())\nclass UserPartial:\n    id: ID\n    firstname: auto\n    lastname: auto\n    ...\n    goat: Optional[CRUDOneToOneUpdateInput[GoatInput, GoatPartial]] = UNSET\n</code></pre></p> <p>Note</p> <p>Currently when using <code>@strawberry_django.partial</code> all fields are marked as optional when auto is used. However, the ID is required for performing nested updates. For consistency and to avoid any errors you should always use <code>id: ID</code> when defining partials for update mutations when it is the root object. The <code>id</code> can be omitted when the partial is used as a nested input and if defined it won't be used in any way to update the related object.</p>"},{"location":"guide/mutations/#one-to-many_1","title":"One to Many","text":"<p><code>CRUDOneToManyUpdateInput</code> can be used when alongside an update mutation you want to update related objects. The resulting schema will provide three possible actions for your mutation and a boolean flag. These are the same as the ones provided by the One to One wrapper, and they function in exactly the same fashion. </p>"},{"location":"guide/mutations/#many-to-one_1","title":"Many to One","text":"<p><code>CRUDManyToOneUpdateInput</code> can be used when alongside an update mutation you want to update related objects. The resulting schema will provide four possible actions  for your mutation. These are as follows:</p> <ul> <li><code>create</code> of type <code>List[UserInput]</code> used to create new related objects.</li> <li><code>assign</code> of type <code>List[ID]</code> used to assign relations with existing objects.</li> <li><code>update</code> of type <code>List[UserPartial]</code> used to update the fields of existing related objects.</li> <li><code>remove</code> of type <code>List[CRUDRemoveInput]</code> which wraps an <code>ID</code> and a <code>bool</code> flag indicating whether the removed object should be deleted. </li> </ul> <p>Note</p> <p>Please note that the <code>UserPartial</code> used in the example above unlike the case with One to Many and One to One has a requirement for the <code>id</code> field. Please take care to ensure the <code>id</code> is declared as mandatory when declaring your input class.</p>"},{"location":"guide/mutations/#many-to-many_1","title":"Many to Many","text":"<p><code>CRUDManyToManyUpdateInput</code> can be used when alongside an update mutation you want to update related objects. The resulting schema will provide four possible actions for your mutation. These are as follows:</p> <ul> <li><code>create</code> of type <code>List[CRUDManyToManyItem]</code> which wraps two inputs.<ul> <li><code>objectData</code> of type <code>UserInput</code> used for the fields of the related object.</li> <li><code>throughDefaults</code> of type <code>JSON</code> used for any data stored in the <code>through</code> model if one exists.</li> </ul> </li> <li><code>assign</code> of type <code>List[CRUDManyToManyID]</code> which wraps two inputs.<ul> <li><code>id</code> of type <code>ID</code> used to assign relations with existing objects.</li> <li><code>throughDefaults</code> of type <code>JSON</code> used for any data stored in the <code>through</code> model if one exists.</li> </ul> </li> <li><code>update</code> of type <code>List[CRUDManyToManyItemUpdate]</code> which wraps two inputs.<ul> <li><code>objectData</code> of type <code>UserPartial</code> used to update the fields of the related object.</li> <li><code>throughDefaults</code> of type <code>JSON</code> used to update the fields of the <code>through</code> model if one exists.</li> </ul> </li> <li><code>remove</code> of type <code>List[CRUDRemoveInput]</code> which wraps an <code>ID</code> and a <code>bool</code> flag indicating whether the removed object should be deleted.</li> </ul> <p>Note</p> <p>Please note that again the <code>UserPartial</code> input must declare an <code>id</code> field of type <code>ID</code> and not <code>auto</code>. </p>"},{"location":"guide/pagination/","title":"Pagination","text":"<p>This field extension allows you to use the default offset limit pagination provided by  strawberry-graphql-django but wraps the results with total count.</p>"},{"location":"guide/pagination/#usage","title":"Usage","text":"<pre><code>import strawberry\nimport strawberry_django\nfrom strawberry_django_extras.field_extensions import with_total_count\n\n@strawberry.type\nclass Query:\n    Users: list[UserType] = strawberry_django.field( \n        extensions=[with_total_count()]\n    )\n</code></pre> <p>Now you can query your list with pagination and total count:</p> <pre><code>{\n  Users(pagination: {offset:0 , limit:1} , order: {lastname: DESC} ) {\n    results {\n      id\n      lastname\n      firstname\n      email  \n    }\n    totalCount\n  }\n}\n</code></pre>"},{"location":"guide/permissions/","title":"Permissions","text":"<p>Similarly to validations, permission checking is run on input instantiation. Since strawberry does not currently provide a way to pass <code>permission_classes</code> to input fields this package allows you to write your permission checking functions as part of the input class. </p> inputs.py<pre><code>@strawberry_django.input(get_user_model())\nclass UserInput:\n    firstname: auto\n    lastname: auto\n\n    def check_permissions(self, info):\n        if not info.context.user.is_staff:\n            raise PermissionDenied(\n                \"You need to be staff to do this\"\n            )\n\n    # Or for individual fields    \n    def check_permissions_lastname(self, info, value):\n        if value == info.context.user.lastname:\n            raise PermissionDenied(\n                \"You cannot create a user with the same lastname as you\"\n            )\n</code></pre> schema.py<pre><code>from strawberry_django_extras.field_extensions import with_permissions\nfrom strawberry_django import mutations\n\n@strawberry.type\nclass Mutation:\n    create_user: UserType = mutations.create(\n        UserInput,\n        extensions=[with_permissions()]\n    )\n</code></pre> <p>Note</p> <p>As documented by Strawberry extension order does matter so make sure you are passing the <code>with_permissions()</code> and <code>with_validation()</code> extensions in an order that makes sense for your project. </p> <p></p>"},{"location":"guide/validation/","title":"Input Validations","text":"<p>Much inspired by the way graphene-django-cud handles validation, this package provides a similar way to validate your input when the respective input classes are instantiated. </p> inputs.py<pre><code>@strawberry_django.input(get_user_model())\nclass UserInput:\n    firstname: auto\n    lastname: auto\n\n    def validate(self, info):\n        if self.firstname == self.lastname:\n            raise ValidationError(\n                \"Firstname and lastname cannot be the same\"\n            )\n\n    # Or for individual fields    \n    def validate_lastname(self, info, value):\n        if value == self.firstname:\n            raise ValidationError(\n                \"Firstname and lastname cannot be the same\"\n            )\n</code></pre> <p>When updating an existing object the <code>pk</code> will be available through <code>self.id</code> so you can validate values in comparison to existing ones. Also info is provided in case validations need to be run against the user making the request. </p> <p>Finally add this to each mutation that needs to run validations: schema.py<pre><code>from strawberry_django_extras.field_extensions import with_validation\nfrom strawberry_django import mutations\n\n@strawberry.type\nclass Mutation:\n    create_user: UserType = mutations.create(\n        UserInput,\n        extensions=[with_validation()]\n    )\n</code></pre></p>"}]}